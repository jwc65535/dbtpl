{{ define "enum" }}
{{- $e := .Data -}}
// {{ $e.GoName }} is the '{{ $e.SQLName }}' enum type.
type {{ $e.GoName }} string

// {{ $e.GoName }} values.
const (
{{- range $e.Values }}
        {{ $e.GoName }}{{ .GoName }} {{ $e.GoName }} = "{{ .SQLName }}"
{{- end }}
)

// String satisfies the Stringer interface.
func ({{ short $e.GoName }} {{ $e.GoName }}) String() string {
        return string({{ short $e.GoName }})
}

// Valid returns whether the value is valid.
func ({{ short $e.GoName }} {{ $e.GoName }}) Valid() bool {
        switch {{ short $e.GoName }} {
{{- range $e.Values }}
        case {{ $e.GoName }}{{ .GoName }}:
                return true
{{- end }}
        }
        return false
}

// Scan implements the pgx Scanner interface.
func ({{ short $e.GoName }} *{{ $e.GoName }}) Scan(v any) error {
        switch x := v.(type) {
        case string:
                *{{ short $e.GoName }} = {{ $e.GoName }}(x)
        case []byte:
                *{{ short $e.GoName }} = {{ $e.GoName }}(x)
        default:
                return fmt.Errorf("cannot scan type %T into {{ $e.GoName }}", v)
        }
        if !{{ short $e.GoName }}.Valid() {
                return fmt.Errorf("invalid {{ $e.GoName }} value: %q", *{{ short $e.GoName }})
        }
        return nil
}
{{ end }}

{{ define "typedef" }}
{{- $t := .Data -}}
{{- if $t.Comment -}}
// {{ $t.Comment | eval $t.GoName }}
{{- else -}}
// {{ $t.GoName }} represents a row from '{{ schema $t.SQLName }}'.
{{- end }}
type {{ $t.GoName }} struct {
{{- range $t.Fields }}
        {{ .GoName }} {{ type .Type }} {{ field_tag . }} // {{ .SQLName }}
{{- end }}
{{- if $t.PrimaryKeys }}
        // internal fields for tracking state
        _exists bool
{{- end }}
}

// Exists returns true when the row exists in the database.
func ({{ short $t.GoName }} *{{ $t.GoName }}) Exists() bool {
        return {{ short $t.GoName }}._exists
}

{{- if $t.PrimaryKeys }}
// Insert inserts the row into the database.
{{ recv_context $t "Insert" }} {
        columns := make([]string, 0, {{ len $t.Fields }})
        values := make([]string, 0, {{ len $t.Fields }})
        args := make([]any, 0, {{ len $t.Fields }})
        param := 1

        add := func(name string, arg any) {
                columns = append(columns, name)
                values = append(values, fmt.Sprintf("$%d", param))
                args = append(args, arg)
                param++
        }

        {{- range $t.Fields }}
        {{- if not .IsSequence }}
        {{- if .HasDefault }}
        if {{ short $t.GoName }}.{{ .GoName }} != nil {
                add("{{ .SQLName }}", {{ short $t.GoName }}.{{ .GoName }})
        }
        {{- else }}
        add("{{ .SQLName }}", {{ short $t.GoName }}.{{ .GoName }})
        {{- end }}
        {{- end }}
        {{- end }}

        sqlstr := fmt.Sprintf("INSERT INTO {{ schema $t.SQLName }} (%s) VALUES (%s)", strings.Join(columns, ", "), strings.Join(values, ", "))
        logf(sqlstr, args...)
        {{- if has_autogenerated_pk $t }}
        if err := {{ db "QueryRow" "args..." }}.Scan(&{{ short $t.GoName }}.{{ (seq_field $t).GoName }}); err != nil {
                return logerror(err)
        }
        {{- else }}
        if _, err := {{ db "Exec" "args..." }}; err != nil {
                return logerror(err)
        }
        {{- end }}
        {{ short $t.GoName }}._exists = true
        return nil
}

// Update updates the row in the database.
{{ recv_context $t "Update" }} {
setClauses := make([]string, 0, {{ len $t.Fields }})
args := make([]any, 0, {{ len $t.Fields }})
param := 1

{{- range $t.Fields }}
{{- if not .IsPrimary }}
{{- if .HasDefault }}
if {{ short $t.GoName }}.{{ .GoName }} != nil {
setClauses = append(setClauses, fmt.Sprintf("{{ .SQLName }} = $%d", param))
args = append(args, {{ short $t.GoName }}.{{ .GoName }})
param++
}
{{- else }}
setClauses = append(setClauses, fmt.Sprintf("{{ .SQLName }} = $%d", param))
args = append(args, {{ short $t.GoName }}.{{ .GoName }})
param++
{{- end }}
{{- end }}
{{- end }}

        where := make([]string, 0, {{ len $t.PrimaryKeys }})
        {{- range $t.PrimaryKeys }}
        where = append(where, fmt.Sprintf("{{ .SQLName }} = $%d", param))
        args = append(args, {{ short $t.GoName }}.{{ .GoName }})
        param++
        {{- end }}

        sqlstr := fmt.Sprintf("UPDATE {{ schema $t.SQLName }} SET %s WHERE %s", strings.Join(setClauses, ", "), strings.Join(where, " AND "))
        logf(sqlstr, args...)
        if _, err := {{ db "Exec" "args..." }}; err != nil {
                return logerror(err)
        }
        return nil
}

// Save saves the row to the database (insert if new, update if exists).
{{ recv_context $t "Save" }} {
        if {{ short $t.GoName }}.Exists() {
                return {{ short $t.GoName }}.Update(ctx, db)
        }
        return {{ short $t.GoName }}.Insert(ctx, db)
}

// Upsert performs an INSERT ... ON CONFLICT DO UPDATE operation.
{{ recv_context $t "Upsert" }} {
        {{ sqlstr "upsert" $t }}
        {{ logf $t }}
        {{- if has_autogenerated_pk $t }}
        if err := {{ db_prefix "QueryRow" true $t }}.Scan(&{{ short $t.GoName }}.{{ (seq_field $t).GoName }}); err != nil {
                return logerror(err)
        }
        {{- else }}
        if _, err := {{ db_prefix "Exec" true $t }}; err != nil {
                return logerror(err)
        }
        {{- end }}
        {{ short $t.GoName }}._exists = true
        return nil
}

// Delete deletes the row from the database.
{{ recv_context $t "Delete" }} {
        {{ sqlstr "delete" $t }}
        {{ logf_pkeys $t }}
        if _, err := {{ db "Exec" (names (print (short $t.GoName) ".") $t.PrimaryKeys) }}; err != nil {
                return logerror(err)
        }
        {{ short $t.GoName }}._exists = false
        return nil
}
{{- end }}
{{ end }}

{{ define "index" }}
{{- $i := .Data -}}
// {{ func_name_context $i }} retrieves a row from '{{ schema $i.Table.SQLName }}' as a [{{ $i.Table.GoName }}].
//
// Generated from index '{{ $i.SQLName }}'.
{{ func_context $i }} {
        {{ sqlstr "index" $i }}
        logf(sqlstr, {{ params $i.Fields false }})
{{- if $i.IsUnique }}
        {{ short $i.Table }} := {{ $i.Table.GoName }}{
        {{- if $i.Table.PrimaryKeys }}
                _exists: true,
        {{- end }}
        }
        if err := {{ db "QueryRow" $i }}.Scan({{ names (print "&" (short $i.Table) ".") $i.Table }}); err != nil {
                return nil, logerror(err)
        }
        return &{{ short $i.Table }}, nil
{{- else }}
        rows, err := {{ db "Query" $i }}
        if err != nil {
                return nil, logerror(err)
        }
        return Collect(rows, func(r pgx.Rows) ({{ $i.Table.GoName }}, error) {
                var {{ short $i.Table }} {{ $i.Table.GoName }}
                {{- if $i.Table.PrimaryKeys }}
                {{ short $i.Table }}._exists = true
                {{- end }}
                err := r.Scan({{ names (print "&" (short $i.Table) ".") $i.Table }})
                return {{ short $i.Table }}, err
        })
{{- end }}
}
{{ end }}

{{ define "foreignkey" }}
{{- $k := .Data -}}
// {{ func_name_context $k }} returns the {{ $k.RefTable }} associated with the [{{ $k.Table.GoName }}]'s ({{ names "" $k.Fields }}).
//
// Generated from foreign key '{{ $k.SQLName }}'.
{{ recv_context $k.Table $k }} {
        return {{ foreign_key_context $k }}
}
{{ end }}
