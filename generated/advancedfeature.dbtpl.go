// Package generated contains generated code for schema 'public'.
package generated

// Code generated by dbtpl (pgx template). DO NOT EDIT.

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

// AdvancedFeature represents a row from 'public.advanced_features'.
type AdvancedFeature struct {
	FeatureID     int                       `json:"feature_id"`     // feature_id
	IntArray      []int                     `json:"int_array"`      // int_array
	TextArray     []string                  `json:"text_array"`     // text_array
	ProcessStatus string                    `json:"process_status"` // process_status
	PointLocation pgtype.Point              `json:"point_location"` // point_location
	IntRange      pgtype.Range[pgtype.Int4] `json:"int_range"`      // int_range
	FileData      []byte                    `json:"file_data"`      // file_data
	EmailAddress  pgtype.Text               `json:"email_address"`  // email_address
	// internal fields for tracking state
	_exists bool
}

// Exists returns true when the row exists in the database.
func (af *AdvancedFeature) Exists() bool {
	return af._exists
}

// Insert inserts the row into the database.
func (af *AdvancedFeature) Insert(ctx context.Context, db DB) error {
	const sqlstr = `INSERT INTO public.advanced_features (` +
		`int_array, text_array, process_status, point_location, int_range, file_data, email_address` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING feature_id`
	logf(sqlstr, af.FeatureID, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress)
	if err := db.QueryRowContext(ctx, sqlstr, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress).Scan(&af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = true
	return nil
}

// Update updates the row in the database.
func (af *AdvancedFeature) Update(ctx context.Context, db DB) error {
	const sqlstr = `UPDATE public.advanced_features SET ` +
		`int_array = $1, text_array = $2, process_status = $3, point_location = $4, int_range = $5, file_data = $6, email_address = $7 ` +
		`WHERE feature_id = $8`
	logf(sqlstr, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress, af.FeatureID)
	if _, err := db.ExecContext(ctx, sqlstr, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress, af.FeatureID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the row to the database (insert if new, update if exists).
func (af *AdvancedFeature) Save(ctx context.Context, db DB) error {
	if af.Exists() {
		return af.Update(ctx, db)
	}
	return af.Insert(ctx, db)
}

// Upsert performs an INSERT ... ON CONFLICT DO UPDATE operation.
func (af *AdvancedFeature) Upsert(ctx context.Context, db DB) error {
	const sqlstr = `INSERT INTO public.advanced_features (` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (feature_id) DO ` +
		`UPDATE SET ` +
		`int_array = EXCLUDED.int_array, text_array = EXCLUDED.text_array, process_status = EXCLUDED.process_status, point_location = EXCLUDED.point_location, int_range = EXCLUDED.int_range, file_data = EXCLUDED.file_data, email_address = EXCLUDED.email_address `
	logf(sqlstr, af.FeatureID, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress)
	if err := db.QueryRowContext(ctx, sqlstr, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress).Scan(&af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = true
	return nil
}

// Delete deletes the row from the database.
func (af *AdvancedFeature) Delete(ctx context.Context, db DB) error {
	const sqlstr = `DELETE FROM public.advanced_features ` +
		`WHERE feature_id = $1`
	logf(sqlstr, af.FeatureID)
	if _, err := db.ExecContext(ctx, sqlstr, af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = false
	return nil
}

// AdvancedFeatureByEmailAddress retrieves a row from 'public.advanced_features' as a [AdvancedFeature].
//
// Generated from index 'advanced_features_email_address_key'.
func AdvancedFeatureByEmailAddress(ctx context.Context, db DB, emailAddress pgtype.Text) (*AdvancedFeature, error) {
	const sqlstr = `SELECT ` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address ` +
		`FROM public.advanced_features ` +
		`WHERE email_address = $1`
	logf(sqlstr, emailAddress)
	af := AdvancedFeature{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, emailAddress).Scan(&af.FeatureID, &af.IntArray, &af.TextArray, &af.ProcessStatus, &af.PointLocation, &af.IntRange, &af.FileData, &af.EmailAddress); err != nil {
		return nil, logerror(err)
	}
	return &af, nil
}

// AdvancedFeatureByFeatureID retrieves a row from 'public.advanced_features' as a [AdvancedFeature].
//
// Generated from index 'advanced_features_pkey'.
func AdvancedFeatureByFeatureID(ctx context.Context, db DB, featureID int) (*AdvancedFeature, error) {
	const sqlstr = `SELECT ` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address ` +
		`FROM public.advanced_features ` +
		`WHERE feature_id = $1`
	logf(sqlstr, featureID)
	af := AdvancedFeature{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, featureID).Scan(&af.FeatureID, &af.IntArray, &af.TextArray, &af.ProcessStatus, &af.PointLocation, &af.IntRange, &af.FileData, &af.EmailAddress); err != nil {
		return nil, logerror(err)
	}
	return &af, nil
}
