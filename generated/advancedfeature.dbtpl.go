// Package generated contains generated code for schema 'public'.
package generated

// Code generated by dbtpl (pgx template). DO NOT EDIT.

import (
	"context"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
)

// AdvancedFeature represents a row from 'public.advanced_features'.
type AdvancedFeature struct {
	FeatureID     int                       `json:"feature_id"`     // feature_id
	IntArray      []int                     `json:"int_array"`      // int_array
	TextArray     []string                  `json:"text_array"`     // text_array
	ProcessStatus *pgtype.Text              `json:"process_status"` // process_status
	PointLocation pgtype.Point              `json:"point_location"` // point_location
	IntRange      pgtype.Range[pgtype.Int4] `json:"int_range"`      // int_range
	FileData      []byte                    `json:"file_data"`      // file_data
	EmailAddress  pgtype.Text               `json:"email_address"`  // email_address
	// internal fields for tracking state
	_exists bool
}

// Exists returns true when the row exists in the database.
func (af *AdvancedFeature) Exists() bool {
	return af._exists
}

// Insert inserts the row into the database.
func (af *AdvancedFeature) Insert(ctx context.Context, db DB) error {
	columns := make([]string, 0, 7)
	values := make([]string, 0, 7)
	args := make([]any, 0, 7)
	param := 1

	add := func(name string, arg any) {
		columns = append(columns, name)
		values = append(values, fmt.Sprintf("$%d", param))
		args = append(args, arg)
		param++
	}

	add("int_array", af.IntArray)
	add("text_array", af.TextArray)
	if af.ProcessStatus != nil {
		add("process_status", af.ProcessStatus)
	}
	add("point_location", af.PointLocation)
	add("int_range", af.IntRange)
	add("file_data", af.FileData)
	add("email_address", af.EmailAddress)

	sqlstr := fmt.Sprintf("INSERT INTO public.advanced_features (%s) VALUES (%s)", strings.Join(columns, ", "), strings.Join(values, ", "))
	logf(sqlstr, args...)
	if err := db.QueryRowContext(ctx, sqlstr, args...).Scan(&af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = true
	return nil
}

// Update updates the row in the database.
func (af *AdvancedFeature) Update(ctx context.Context, db DB) error {
	setClauses := make([]string, 0, 7)
	args := make([]any, 0, 7)
	param := 1

	setClauses = append(setClauses, fmt.Sprintf("int_array = $%d", param))
	args = append(args, af.IntArray)
	param++

	setClauses = append(setClauses, fmt.Sprintf("text_array = $%d", param))
	args = append(args, af.TextArray)
	param++

	if af.ProcessStatus != nil {
		setClauses = append(setClauses, fmt.Sprintf("process_status = $%d", param))
		args = append(args, af.ProcessStatus)
		param++
	}

	setClauses = append(setClauses, fmt.Sprintf("point_location = $%d", param))
	args = append(args, af.PointLocation)
	param++

	setClauses = append(setClauses, fmt.Sprintf("int_range = $%d", param))
	args = append(args, af.IntRange)
	param++

	setClauses = append(setClauses, fmt.Sprintf("file_data = $%d", param))
	args = append(args, af.FileData)
	param++

	setClauses = append(setClauses, fmt.Sprintf("email_address = $%d", param))
	args = append(args, af.EmailAddress)
	param++

	where := fmt.Sprintf("feature_id = $%d", param)
	args = append(args, af.FeatureID)

	sqlstr := fmt.Sprintf("UPDATE public.advanced_features SET %s WHERE %s", strings.Join(setClauses, ", "), where)
	logf(sqlstr, args...)
	if _, err := db.ExecContext(ctx, sqlstr, args...); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the row to the database (insert if new, update if exists).
func (af *AdvancedFeature) Save(ctx context.Context, db DB) error {
	if af.Exists() {
		return af.Update(ctx, db)
	}
	return af.Insert(ctx, db)
}

// Upsert performs an INSERT ... ON CONFLICT DO UPDATE operation.
func (af *AdvancedFeature) Upsert(ctx context.Context, db DB) error {
	const sqlstr = `INSERT INTO public.advanced_features (` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (feature_id) DO ` +
		`UPDATE SET ` +
		`int_array = EXCLUDED.int_array, text_array = EXCLUDED.text_array, process_status = EXCLUDED.process_status, point_location = EXCLUDED.point_location, int_range = EXCLUDED.int_range, file_data = EXCLUDED.file_data, email_address = EXCLUDED.email_address `
	logf(sqlstr, af.FeatureID, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress)
	if err := db.QueryRowContext(ctx, sqlstr, af.IntArray, af.TextArray, af.ProcessStatus, af.PointLocation, af.IntRange, af.FileData, af.EmailAddress).Scan(&af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = true
	return nil
}

// Delete deletes the row from the database.
func (af *AdvancedFeature) Delete(ctx context.Context, db DB) error {
	const sqlstr = `DELETE FROM public.advanced_features ` +
		`WHERE feature_id = $1`
	logf(sqlstr, af.FeatureID)
	if _, err := db.ExecContext(ctx, sqlstr, af.FeatureID); err != nil {
		return logerror(err)
	}
	af._exists = false
	return nil
}

// AdvancedFeatureByEmailAddress retrieves a row from 'public.advanced_features' as a [AdvancedFeature].
//
// Generated from index 'advanced_features_email_address_key'.
func AdvancedFeatureByEmailAddress(ctx context.Context, db DB, emailAddress pgtype.Text) (*AdvancedFeature, error) {
	const sqlstr = `SELECT ` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address ` +
		`FROM public.advanced_features ` +
		`WHERE email_address = $1`
	logf(sqlstr, emailAddress)
	af := AdvancedFeature{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, emailAddress).Scan(&af.FeatureID, &af.IntArray, &af.TextArray, &af.ProcessStatus, &af.PointLocation, &af.IntRange, &af.FileData, &af.EmailAddress); err != nil {
		return nil, logerror(err)
	}
	return &af, nil
}

// AdvancedFeatureByFeatureID retrieves a row from 'public.advanced_features' as a [AdvancedFeature].
//
// Generated from index 'advanced_features_pkey'.
func AdvancedFeatureByFeatureID(ctx context.Context, db DB, featureID int) (*AdvancedFeature, error) {
	const sqlstr = `SELECT ` +
		`feature_id, int_array, text_array, process_status, point_location, int_range, file_data, email_address ` +
		`FROM public.advanced_features ` +
		`WHERE feature_id = $1`
	logf(sqlstr, featureID)
	af := AdvancedFeature{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, featureID).Scan(&af.FeatureID, &af.IntArray, &af.TextArray, &af.ProcessStatus, &af.PointLocation, &af.IntRange, &af.FileData, &af.EmailAddress); err != nil {
		return nil, logerror(err)
	}
	return &af, nil
}
