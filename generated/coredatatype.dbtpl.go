package generated

// Code generated by dbtpl (pgx template). DO NOT EDIT.

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// CoreDataType represents a row from 'public.core_data_types'.
type CoreDataType struct {
	ID                 int              `json:"id"`                   // id
	SmallIntVal        int16            `json:"small_int_val"`        // small_int_val
	IntegerVal         int              `json:"integer_val"`          // integer_val
	BigIntVal          int64            `json:"big_int_val"`          // big_int_val
	NumericVal         pgtype.Numeric   `json:"numeric_val"`          // numeric_val
	RealVal            pgtype.Float4    `json:"real_val"`             // real_val
	DoublePrecisionVal pgtype.Float8    `json:"double_precision_val"` // double_precision_val
	CharVal            string           `json:"char_val"`             // char_val
	VarcharVal         string           `json:"varchar_val"`          // varchar_val
	TextVal            pgtype.Text      `json:"text_val"`             // text_val
	BooleanVal         bool             `json:"boolean_val"`          // boolean_val
	DateVal            time.Time        `json:"date_val"`             // date_val
	TimeVal            pgtype.Time      `json:"time_val"`             // time_val
	TimestampVal       time.Time        `json:"timestamp_val"`        // timestamp_val
	TimestamptzVal     time.Time        `json:"timestamptz_val"`      // timestamptz_val
	IntervalVal        pgtype.Interval  `json:"interval_val"`         // interval_val
	UUIDVal            *pgtype.UUID     `json:"uuid_val"`             // uuid_val
	JsonbDataNullable  *json.RawMessage `json:"jsonb_data_nullable"`  // jsonb_data_nullable
	JsonbData          json.RawMessage  `json:"jsonb_data"`           // jsonb_data
	NullableInt        pgtype.Int4      `json:"nullable_int"`         // nullable_int
	NullableText       pgtype.Text      `json:"nullable_text"`        // nullable_text
	NullableTime       pgtype.Time      `json:"nullable_time"`        // nullable_time
	// internal fields for tracking state
	_exists bool
}

// Exists returns true when the row exists in the database.
func (cdt *CoreDataType) Exists() bool {
	return cdt._exists
}

// Insert inserts the row into the database.
func (cdt *CoreDataType) Insert(ctx context.Context, db DB) error {
	columns := make([]string, 0, 22)
	values := make([]string, 0, 22)
	args := make([]any, 0, 22)
	param := 1

	add := func(name string, arg any) {
		columns = append(columns, name)
		values = append(values, fmt.Sprintf("$%d", param))
		args = append(args, arg)
		param++
	}
	add("small_int_val", cdt.SmallIntVal)
	add("integer_val", cdt.IntegerVal)
	add("big_int_val", cdt.BigIntVal)
	add("numeric_val", cdt.NumericVal)
	add("real_val", cdt.RealVal)
	add("double_precision_val", cdt.DoublePrecisionVal)
	add("char_val", cdt.CharVal)
	add("varchar_val", cdt.VarcharVal)
	add("text_val", cdt.TextVal)
	add("boolean_val", cdt.BooleanVal)
	add("date_val", cdt.DateVal)
	add("time_val", cdt.TimeVal)
	add("timestamp_val", cdt.TimestampVal)
	add("timestamptz_val", cdt.TimestamptzVal)
	add("interval_val", cdt.IntervalVal)
	if cdt.UUIDVal != nil {
		add("uuid_val", cdt.UUIDVal)
	}
	add("jsonb_data_nullable", cdt.JsonbDataNullable)
	add("jsonb_data", cdt.JsonbData)
	add("nullable_int", cdt.NullableInt)
	add("nullable_text", cdt.NullableText)
	add("nullable_time", cdt.NullableTime)

	sqlstr := fmt.Sprintf("INSERT INTO public.core_data_types (%s) VALUES (%s)", strings.Join(columns, ", "), strings.Join(values, ", "))
	logf(sqlstr, args...)
	if err := db.QueryRowContext(ctx, sqlstr, args...).Scan(&cdt.ID); err != nil {
		return logerror(err)
	}
	cdt._exists = true
	return nil
}

// Update updates the row in the database.
func (cdt *CoreDataType) Update(ctx context.Context, db DB) error {
	setClauses := make([]string, 0, 22)
	args := make([]any, 0, 22)
	param := 1

	add := func(name string, arg any) {
		setClauses = append(setClauses, fmt.Sprintf("%s = $%d", name, param))
		args = append(args, arg)
		param++
	}
	add("small_int_val", cdt.SmallIntVal)
	add("integer_val", cdt.IntegerVal)
	add("big_int_val", cdt.BigIntVal)
	add("numeric_val", cdt.NumericVal)
	add("real_val", cdt.RealVal)
	add("double_precision_val", cdt.DoublePrecisionVal)
	add("char_val", cdt.CharVal)
	add("varchar_val", cdt.VarcharVal)
	add("text_val", cdt.TextVal)
	add("boolean_val", cdt.BooleanVal)
	add("date_val", cdt.DateVal)
	add("time_val", cdt.TimeVal)
	add("timestamp_val", cdt.TimestampVal)
	add("timestamptz_val", cdt.TimestamptzVal)
	add("interval_val", cdt.IntervalVal)
	if cdt.UUIDVal != nil {
		add("uuid_val", cdt.UUIDVal)
	}
	add("jsonb_data_nullable", cdt.JsonbDataNullable)
	add("jsonb_data", cdt.JsonbData)
	add("nullable_int", cdt.NullableInt)
	add("nullable_text", cdt.NullableText)
	add("nullable_time", cdt.NullableTime)

	where := make([]string, 0, 1)
	where = append(where, fmt.Sprintf("id = $%d", param))
	args = append(args, cdt.ID)
	param++

	sqlstr := fmt.Sprintf("UPDATE public.core_data_types SET %s WHERE %s", strings.Join(setClauses, ", "), strings.Join(where, " AND "))
	logf(sqlstr, args...)
	if _, err := db.ExecContext(ctx, sqlstr, args...); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the row to the database (insert if new, update if exists).
func (cdt *CoreDataType) Save(ctx context.Context, db DB) error {
	if cdt.Exists() {
		return cdt.Update(ctx, db)
	}
	return cdt.Insert(ctx, db)
}

// Upsert performs an INSERT ... ON CONFLICT DO UPDATE operation.
func (cdt *CoreDataType) Upsert(ctx context.Context, db DB) error {
	const sqlstr = `INSERT INTO public.core_data_types (` +
		`id, small_int_val, integer_val, big_int_val, numeric_val, real_val, double_precision_val, char_val, varchar_val, text_val, boolean_val, date_val, time_val, timestamp_val, timestamptz_val, interval_val, uuid_val, jsonb_data_nullable, jsonb_data, nullable_int, nullable_text, nullable_time` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`small_int_val = EXCLUDED.small_int_val, integer_val = EXCLUDED.integer_val, big_int_val = EXCLUDED.big_int_val, numeric_val = EXCLUDED.numeric_val, real_val = EXCLUDED.real_val, double_precision_val = EXCLUDED.double_precision_val, char_val = EXCLUDED.char_val, varchar_val = EXCLUDED.varchar_val, text_val = EXCLUDED.text_val, boolean_val = EXCLUDED.boolean_val, date_val = EXCLUDED.date_val, time_val = EXCLUDED.time_val, timestamp_val = EXCLUDED.timestamp_val, timestamptz_val = EXCLUDED.timestamptz_val, interval_val = EXCLUDED.interval_val, uuid_val = EXCLUDED.uuid_val, jsonb_data_nullable = EXCLUDED.jsonb_data_nullable, jsonb_data = EXCLUDED.jsonb_data, nullable_int = EXCLUDED.nullable_int, nullable_text = EXCLUDED.nullable_text, nullable_time = EXCLUDED.nullable_time `
	logf(sqlstr, cdt.ID, cdt.SmallIntVal, cdt.IntegerVal, cdt.BigIntVal, cdt.NumericVal, cdt.RealVal, cdt.DoublePrecisionVal, cdt.CharVal, cdt.VarcharVal, cdt.TextVal, cdt.BooleanVal, cdt.DateVal, cdt.TimeVal, cdt.TimestampVal, cdt.TimestamptzVal, cdt.IntervalVal, cdt.UUIDVal, cdt.JsonbDataNullable, cdt.JsonbData, cdt.NullableInt, cdt.NullableText, cdt.NullableTime)
	if err := db.QueryRowContext(ctx, sqlstr, cdt.SmallIntVal, cdt.IntegerVal, cdt.BigIntVal, cdt.NumericVal, cdt.RealVal, cdt.DoublePrecisionVal, cdt.CharVal, cdt.VarcharVal, cdt.TextVal, cdt.BooleanVal, cdt.DateVal, cdt.TimeVal, cdt.TimestampVal, cdt.TimestamptzVal, cdt.IntervalVal, cdt.UUIDVal, cdt.JsonbDataNullable, cdt.JsonbData, cdt.NullableInt, cdt.NullableText, cdt.NullableTime).Scan(&cdt.ID); err != nil {
		return logerror(err)
	}
	cdt._exists = true
	return nil
}

// Delete deletes the row from the database.
func (cdt *CoreDataType) Delete(ctx context.Context, db DB) error {
	const sqlstr = `DELETE FROM public.core_data_types ` +
		`WHERE id = $1`
	logf(sqlstr, cdt.ID)
	if _, err := db.ExecContext(ctx, sqlstr, cdt.ID); err != nil {
		return logerror(err)
	}
	cdt._exists = false
	return nil
}

// CoreDataTypeByID retrieves a row from 'public.core_data_types' as a [CoreDataType].
//
// Generated from index 'core_data_types_pkey'.
func CoreDataTypeByID(ctx context.Context, db DB, id int) (*CoreDataType, error) {
	const sqlstr = `SELECT ` +
		`id, small_int_val, integer_val, big_int_val, numeric_val, real_val, double_precision_val, char_val, varchar_val, text_val, boolean_val, date_val, time_val, timestamp_val, timestamptz_val, interval_val, uuid_val, jsonb_data_nullable, jsonb_data, nullable_int, nullable_text, nullable_time ` +
		`FROM public.core_data_types ` +
		`WHERE id = $1`
	logf(sqlstr, id)
	cdt := CoreDataType{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&cdt.ID, &cdt.SmallIntVal, &cdt.IntegerVal, &cdt.BigIntVal, &cdt.NumericVal, &cdt.RealVal, &cdt.DoublePrecisionVal, &cdt.CharVal, &cdt.VarcharVal, &cdt.TextVal, &cdt.BooleanVal, &cdt.DateVal, &cdt.TimeVal, &cdt.TimestampVal, &cdt.TimestamptzVal, &cdt.IntervalVal, &cdt.UUIDVal, &cdt.JsonbDataNullable, &cdt.JsonbData, &cdt.NullableInt, &cdt.NullableText, &cdt.NullableTime); err != nil {
		return nil, logerror(err)
	}
	return &cdt, nil
}
